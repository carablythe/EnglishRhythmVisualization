<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>English Rhythm Visualization</title>
    <style>

        body {
            font-family: 'Arial', sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #4a5568;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-style: italic;
        }
        
        textarea {
            width: 100%;
            height: 120px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 15px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s ease;
            box-sizing: border-box;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 20px 0;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }
        
   .visualization {
    margin-top: 30px;
    padding: 60px 25px 25px 25px;  /* Added more top padding */
    background: #f8fafc;
    border-radius: 15px;
    border: 1px solid #e2e8f0;
    min-height: 200px;
}
        
        .word-container {
           position: relative;
           display: inline-block;
           margin: 5px 8px 70px 8px;  /* Increased bottom margin */
            vertical-align: top;
        }
        
        .intonation-line {
    position: absolute;
    top: -45px; 
    left: 0;
    right: 0;
    height: 45px;
    stroke: #667eea;
    stroke-width: 2.5;
    fill: none;
}
        
      .breath-mark {
    position: absolute;
    top: -35px;
    right: -12px;
    width: 2px;
    height: 30px;
    background-color: #4a5568;
    opacity: 0.7;
}

.breath-mark[style*="left"] {
    right: auto; 
}
        
        .word-text {
            font-size: 18px;
            font-weight: 500;
            color: #2d3748;
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        .stressed {
            background-color: rgba(102, 126, 234, 0.1);
            font-weight: 700;
        }
        
        .legend {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }
        
        .legend h3 {
            margin-top: 0;
            color: #4a5568;
        }
        
        .legend-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 10px;
            border-radius: 1px;
        }
        
        .example-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .example-buttons {
                flex-direction: column;
                align-items: center;
            }
        }
   </style>
    
    
    
</head>
<body>
    <div class="container">
        <h1>English Rhythm Visualization</h1>
        <p class="subtitle">Visualize English speech patterns and stress</p>
       <p class="subtitle">英語の音声パターンと強勢を視覚化</p>
        
         <textarea id="textInput" placeholder="Enter your English text here (ここに英語のテキストを入力してください)"></textarea>
        
        
            <button onclick="analyzeIntonation()">Analyze Rhythm (リズム分析)</button>

          <div id="visualization" class="visualization"> 
        </div>
           
        
        <div>
            <p style="text-align: center; color: #718096; font-style: italic;">
                See below how to interpret your results. (結果の解釈方法については下記の凡例をご覧ください。)</p>
        </div>
        
        <div class="legend">
            <h3>Key (凡例)</h3>
          
           <h4>Word/Syllable Stress(文強勢): </h4>
          <span>Please pay attention to the line above each word for the syllable stress. The line going up means that part of the word is stressed and going down means there is an unstressed syllable. (それぞれの単語の上にある線に注目してください。線が上に上がっているところは、その部分にアクセント（強勢）があることを示し、下がっているところはアクセントのない音節を表しています。)</span>
             <h4>Sentence Stress(文強勢): </h4>
            <div class="legend-item">
                <div class="legend-line" style="background: #e53e3e;"></div>
                <span>Primary sentence stress: longest, loudest (第一文強勢: 最も長く、最も大きく)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #f56500;"></div>
                <span>Secondary sentence stress: medium (第二文強勢: 中程度)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #667eea;"></div>
                <span>Weak sentence stress: slightly elevated (弱文強勢: やや高め)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #a0aec0;"></div>
                <span>Unstressed: shortest, quietest (無強勢: 最も短く、最も小さく)</span>
            </div>
            
               <h4>Breath/Pause Marks(息継ぎ・ポーズマーク): </h4>
            <div class="legend-item">
                <div style="width: 2px; height: 30px; background-color: #4a5568; margin-right: 10px; opacity: 0.7;"></div>
            
                <span>　Such as after punctuation, before conjunctions, before relative clauses or long prepositional phrases (句読点、接続詞の前、関係節や長い前置詞句の前等)</span>
            </div>
    
          <h4>Intonation (抑揚): </h4>
            <div class="legend-item">
               <svg width="30" height="30" viewBox="0 0 60 30">
    <path d="M5 25 Q30 25 55 5" stroke="#CBA6F7" stroke-width="3" fill="none" />
  </svg>
               <span> Rising pitch: Yes/No Questions, tag questions (上昇調：Yes/No疑問文、付加疑問文)</span>
            </div>
            <div class="legend-item">
                <svg width="30" height="30" viewBox="0 0 60 30">
    <path d="M5 5 Q30 5 55 25" stroke="#CBA6F7" stroke-width="3" fill="none" />
  </svg>
                <span> Falling pitch: Statements, commands, open-ended/Wh-questions (下降調：平叙文、命令文、Wh疑問文) </span>
            </div>
        </div>
    </div>

     <script src="https://cdn.jsdelivr.net/npm/compromise@14.14.0/builds/compromise.min.js"></script>
 
    <!-- Load compromise.js FIRST -->
    
    <script>
     
// CMU Dictionary cache
let cmuDict = null;
let isLoading = false;

// Load CMU Dictionary from GitHub raw file
function loadCMUDictionary() {
  if (cmuDict || isLoading) return;

  isLoading = true;
  fetch(
    "https://raw.githubusercontent.com/Timmald/CMUdict_json/refs/heads/main/cmu_dict.json"
  )
    .then((response) => response.json())
    .then((data) => {
      cmuDict = data;
      isLoading = false;
      console.log("CMU Dictionary loaded successfully");
    })
    .catch((error) => {
      console.warn("Failed to load CMU dictionary, using fallback");
      isLoading = false;
    });
}

// Extract stress pattern from CMU pronunciation
function getStressPatternFromCMU(pronunciation) {
  if (!pronunciation) return [];

  const phonemes = pronunciation.split(" ");
  const stressPattern = [];

  for (let i = 0; i < phonemes.length; i++) {
    const phoneme = phonemes[i];
    if (phoneme.match(/\d$/)) {
      stressPattern.push(parseInt(phoneme.slice(-1)));
    }
  }

  return stressPattern.length > 0 ? stressPattern : [];
}



// Common English function words (typically unstressed)
const functionWords = new Set([
  'a', 'an', 'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
  'from', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'enough',
  'up', 'down', 'out', 'off', 'over', 'under', 'around', 'within', 'again', 'further', 'then', 'once',
  'until', 'because', 'without', 'between', 'among', 'beyond', 'beneath', 'beside', 'become'
]);


// Words that typically receive emphasis
const emphasisWords = new Set([
  "very",
  "amazing",
  "terrible",
  "great",
  "excellent",
  "maybe",
  "perhaps"
]);

// Fallback POS dictionary for words Compromise often misses
const fallbackNouns = new Set([
  "stress", "level", "levels", "type", "types", "information", "emphasis",
  "sentence", "sentences", "degree", "degrees", "word", "words", "model",
  "primary", "secondary", "tertiary", "description", "descriptions",
  "tonic", "contrast", "standard", "frequency", "encourage", "english",
  "language", "speech", "pattern", "patterns", "rhythm", "syllable", "syllables",
  "pronunciation", "intonation", "pitch", "tone", "vowel", "consonant",
  "phoneme", "phonemes", "sound", "sounds", "accent", "dialect",
  "question", "statement", "exclamation", "command", "phrase", "clause",
  "noun", "verb", "adjective", "adverb", "pronoun", "article",
  "example", "examples", "case", "cases", "rule", "rules", "exception",
  "category", "categories", "group", "groups", "set", "sets",
  "business", "market", "customer", "customers", "product", "products",
  "service", "services", "company", "companies", "opportunity", "opportunities",
  "challenge", "challenges", "solution", "solutions", "problem", "problems",
  "strategy", "strategies", "goal", "goals", "objective", "objectives",
  "result", "results", "outcome", "outcomes", "performance", "quality",
  "value", "cost", "costs", "price", "prices", "revenue", "profit",
  "expense", "expenses", "budget", "investment", "growth", "change",
  "improvement", "efficiency", "effectiveness", "success", "failure",
  "risk", "risks", "benefit", "benefits", "advantage", "disadvantage",
  "process", "processes", "system", "systems", "method", "methods",
  "approach", "approaches", "technique", "techniques", "tool", "tools",
  "resource", "resources", "data", "analysis", "report", "reports",
  "research", "study", "studies", "finding", "findings", "evidence",
  "fact", "facts", "detail", "details", "aspect", "aspects",
  "feature", "features", "element", "elements", "component", "components",
  "part", "parts", "section", "sections", "area", "areas", "field",
  "topic", "topics", "subject", "subjects", "issue", "issues",
  "matter", "matters", "point", "points", "factor", "factors",
  "reason", "reasons", "cause", "causes", "effect", "effects",
  "impact", "impacts", "influence", "consequence", "consequences",
  "relationship", "relationships", "connection", "connections", "link",
  "difference", "differences", "similarity", "similarities", "comparison",
  "time", "period", "moment", "day", "week", "month", "year",
  "place", "location", "position", "situation", "condition", "state",
  "way", "manner", "form", "kind", "sort", "variety"
]);

const fallbackVerbs = new Set([
  "convey", "conveys", "conveyed", "conveying",
  "include", "includes", "included", "including",
  "mention", "mentions", "mentioned", "mentioning",
  "describe", "describes", "described", "describing",
  "indicate", "indicates", "indicated", "indicating",
  "suggest", "suggests", "suggested", "suggesting",
  "show", "shows", "showed", "shown", "showing",
  "demonstrate", "demonstrates", "demonstrated", "demonstrating",
  "represent", "represents", "represented", "representing",
  "emphasize", "emphasizes", "emphasized", "emphasizing",
  "stress", "stresses", "stressed", "stressing",
  "focus", "focuses", "focused", "focusing",
  "highlight", "highlights", "highlighted", "highlighting",
  "illustrate", "illustrates", "illustrated", "illustrating",
  "explain", "explains", "explained", "explaining",
  "clarify", "clarifies", "clarified", "clarifying",
  "define", "defines", "defined", "defining",
  "identify", "identifies", "identified", "identifying",
  "recognize", "recognizes", "recognized", "recognizing",
  "distinguish", "distinguishes", "distinguished", "distinguishing",
  "compare", "compares", "compared", "comparing",
  "contrast", "contrasts", "contrasted", "contrasting",
  "analyze", "analyzes", "analyzed", "analyzing",
  "examine", "examines", "examined", "examining",
  "consider", "considers", "considered", "considering",
  "discuss", "discusses", "discussed", "discussing",
  "present", "presents", "presented", "presenting",
  "provide", "provides", "provided", "providing",
  "offer", "offers", "offered", "offering",
  "give", "gives", "gave", "given", "giving",
  "contain", "contains", "contained", "containing",
  "involve", "involves", "involved", "involving",
  "require", "requires", "required", "requiring",
  "need", "needs", "needed", "needing",
  "use", "uses", "used", "using",
  "apply", "applies", "applied", "applying",
  "employ", "employs", "employed", "employing",
  "create", "creates", "created", "creating",
  "produce", "produces", "produced", "producing",
  "generate", "generates", "generated", "generating",
  "develop", "develops", "developed", "developing",
  "establish", "establishes", "established", "establishing",
  "form", "forms", "formed", "forming",
  "build", "builds", "built", "building",
  "make", "makes", "made", "making",
  "achieve", "achieves", "achieved", "achieving",
  "reach", "reaches", "reached", "reaching",
  "obtain", "obtains", "obtained", "obtaining",
  "gain", "gains", "gained", "gaining",
  "receive", "receives", "received", "receiving",
  "acquire", "acquires", "acquired", "acquiring",
  "improve", "improves", "improved", "improving",
  "enhance", "enhances", "enhanced", "enhancing",
  "increase", "increases", "increased", "increasing",
  "decrease", "decreases", "decreased", "decreasing",
  "reduce", "reduces", "reduced", "reducing",
  "maintain", "maintains", "maintained", "maintaining",
  "support", "supports", "supported", "supporting",
  "help", "helps", "helped", "helping",
  "enable", "enables", "enabled", "enabling",
  "allow", "allows", "allowed", "allowing",
  "cause", "causes", "caused", "causing",
  "lead", "leads", "led", "leading",
  "result", "results", "resulted", "resulting",
  "occur", "occurs", "occurred", "occurring",
  "happen", "happens", "happened", "happening",
  "exist", "exists", "existed", "existing",
  "appear", "appears", "appeared", "appearing",
  "seem", "seems", "seemed", "seeming",
  "become", "becomes", "became", "becoming",
  "remain", "remains", "remained", "remaining",
  "continue", "continues", "continued", "continuing"
]);

const fallbackAdjectives = new Set([
  "unstressed", "stressed", "primary", "secondary", "tertiary",
  "emphatic", "contrastive", "tonic", "basic", "standard",
  "physical", "rare", "different", "various", "several",
  "important", "significant", "major", "minor", "main",
  "common", "uncommon", "typical", "unusual", "normal",
  "regular", "irregular", "standard", "special", "particular",
  "specific", "general", "certain", "possible", "probable",
  "necessary", "essential", "critical", "crucial", "vital",
  "useful", "helpful", "effective", "efficient", "practical",
  "simple", "complex", "complicated", "difficult", "easy",
  "clear", "unclear", "obvious", "apparent", "evident",
  "strong", "weak", "high", "low", "large", "small",
  "great", "little", "big", "huge", "tiny", "massive",
  "positive", "negative", "good", "bad", "better", "worse",
  "best", "worst", "excellent", "poor", "superior", "inferior",
  "new", "old", "recent", "current", "modern", "traditional",
  "early", "late", "first", "last", "next", "previous",
  "similar", "different", "same", "other", "another", "such",
  "full", "empty", "complete", "incomplete", "total", "partial",
  "whole", "entire", "all", "some", "many", "few",
  "much", "little", "more", "less", "most", "least",
  "long", "short", "wide", "narrow", "broad", "deep",
  "direct", "indirect", "immediate", "gradual", "sudden", "quick",
  "fast", "slow", "rapid", "swift", "steady", "constant",
  "consistent", "variable", "stable", "unstable", "fixed", "flexible",
  "hard", "soft", "firm", "solid", "liquid", "dense",
  "light", "heavy", "thick", "thin", "coarse", "fine",
  "rough", "smooth", "sharp", "dull", "bright", "dark",
  "loud", "quiet", "noisy", "silent", "audible", "inaudible"
]);

const numberWords = new Set([
  "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
  "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", 
  "seventeen", "eighteen", "nineteen", "twenty", "thirty", "forty", "fifty",
  "sixty", "seventy", "eighty", "ninety", "hundred", "thousand", "million",
  "billion", "trillion", "first", "second", "third", "fourth", "fifth",
  "sixth", "seventh", "eighth", "ninth", "tenth", "eleventh", "twelfth"
]);


function analyzeSentencePOS(sentence) {
  const words = sentence.trim().split(/\s+/);
  const posMap = new Map();

  try {
    const cleanSentence = sentence.replace(/[.!?,;:]/g, "");
    const doc = nlp(cleanSentence);

    // Extract all nouns with their text
    doc.nouns().forEach((noun) => {
      const text = noun.text().toLowerCase();
      posMap.set(text, "noun");
    });

    // Extract all verbs
    doc.verbs().forEach((verb) => {
      const text = verb.text().toLowerCase();
      if (!posMap.has(text)) {
        posMap.set(text, "verb");
      }
    });

    // Extract adjectives
    doc.adjectives().forEach((adj) => {
      const text = adj.text().toLowerCase();
      if (!posMap.has(text)) {
        posMap.set(text, "adjective");
      }
    });

    // Extract adverbs
    doc.adverbs().forEach((adv) => {
      const text = adv.text().toLowerCase();
      if (!posMap.has(text)) {
        posMap.set(text, "adverb");
      }
    });

    // Extract pronouns
    doc.pronouns().forEach((pron) => {
      const text = pron.text().toLowerCase();
      if (!posMap.has(text)) {
        posMap.set(text, "pronoun");
      }
    });

    // Extract prepositions
    doc.prepositions().forEach((prep) => {
      const text = prep.text().toLowerCase();
      if (!posMap.has(text)) {
        posMap.set(text, "preposition");
      }
    });

    // Extract conjunctions
    doc.conjunctions().forEach((conj) => {
      const text = conj.text().toLowerCase();
      if (!posMap.has(text)) {
        posMap.set(text, "conjunction");
      }
    });
  } catch (error) {
    console.warn("Sentence POS analysis failed:", error);
  }

  // Override incorrect compromise.js tags for common pronouns
const pronounOverrides = new Set([
  'i','you','he','she','it','we','they','me','him','her','us','them',
  'my','your','his','her','its','our','their','this','that','these','those'
]);

words.forEach(word => {
  const cleanWord = word.toLowerCase().replace(/[^\w']/g, "");
  if (pronounOverrides.has(cleanWord)) {
    posMap.set(cleanWord, 'pronoun');
  }
});
  
  
  // Check each word against fallback dictionaries if not already tagged
words.forEach((word, index) => {
  const cleanWord = word.toLowerCase().replace(/[^\w']/g, "");
  if (!posMap.has(cleanWord) && cleanWord) {
    // Check if it's a number (numeral or word form)
    if (cleanWord.match(/^\d+$/) || numberWords.has(cleanWord)) {
      posMap.set(cleanWord, "number");
      return; // Skip further checks for numbers
    }
    
  
// Special case: -ed words before nouns are likely adjectives ONLY in attributive position
if (cleanWord.endsWith('ed') && index < words.length - 1) {
  const nextWord = words[index + 1].toLowerCase().replace(/[^\w']/g, "");
  
  // Check if next word is a noun (3-tier check: compromise.js, fallback list, then suffixes)
  const isNoun = posMap.get(nextWord) === 'noun' || 
                 fallbackNouns.has(nextWord) ||
                 nextWord.match(/(tion|sion|ness|ment|ance|ence|ancy|ency|ity|ty|ism|ist|er|or|age|ure|ship|hood|dom|tude|ery|ary|ory|ant|ent|logy|gy|metry|graphy|phy|ics|cy|ade|ette|let|ee|eer)$/);
  
  if (isNoun) {
    // Additional check: is there a determiner, possessive, or quantifier before this -ed word?
    // These indicate attributive adjective position
    const determiners = new Set(['a', 'an', 'the', 'this', 'that', 'these', 'those', 'my', 'your', 'his', 'her', 'its', 'our', 'their', 'some', 'any', 'no', 'many', 'much', 'several', 'few', 'all', 'both', 'each', 'every']);
    
    if (index > 0) {
      const prevWord = words[index - 1].toLowerCase().replace(/[^\w']/g, "");
      // If preceded by determiner/possessive, treat as adjective
      if (determiners.has(prevWord)) {
        posMap.set(cleanWord, "adjective");
        return;
      }
    }
    
    // If -ed word is the first word after punctuation or at sentence start, likely a verb
    if (index === 0 || words[index - 1].match(/[.!?,;:]/)) {
      return; // Don't tag as adjective, let it fall through to verb checking
    }
  }
}
    
    // Check fallback dictionaries in order of priority
    if (fallbackNouns.has(cleanWord)) {
      posMap.set(cleanWord, "noun");
    } else if (fallbackVerbs.has(cleanWord)) {
      posMap.set(cleanWord, "verb");
    } else if (fallbackAdjectives.has(cleanWord)) {
      posMap.set(cleanWord, "adjective");
    }
  }
});

  return posMap;
}

function analyzeIntonation() {
  console.log("analyzeIntonation() called");

  const text = document.getElementById("textInput").value.trim();
  if (!text) {
    alert("Please enter some text to analyze!");
    return;
  }

  // Start loading dictionary if not already loaded
  if (!cmuDict && !isLoading) {
    loadCMUDictionary();
  }

  const visualization = document.getElementById("visualization");
  visualization.innerHTML = "";

  // Parse sentences
  const sentences = text.match(/[^.!?]*[.!?]+/g) || [text];

  sentences.forEach((sentence) => {
    if (sentence.trim()) {
      const sentenceDiv = document.createElement("div");
      sentenceDiv.style.marginBottom = "40px";

      const words = sentence.trim().split(/\s+/);
      const intonationType = detectIntonationType(sentence);

      // Analyze POS for entire sentence once
      const posMap = analyzeSentencePOS(sentence);
      console.log("POS Map for sentence:", sentence.trim());
      console.log("Map contents:", Array.from(posMap.entries()));
      words.forEach((word, index) => {
        const wordContainer = document.createElement("div");
        wordContainer.className = "word-container";

        // Clean word (remove punctuation for analysis) but preserve case for acronym detection
        const cleanWord = word.replace(/[^\w]/g, "");
        const syllables = getImprovedSyllables(cleanWord);
        const isAcronym =
          cleanWord.match(/^[A-Z]{2,}$/) && !new Set(["LINE"]).has(cleanWord);
        const stressPattern = getSyllableStress(
          cleanWord,
          syllables,
          isAcronym
        );
        const sentenceStress = getSentenceStress(
          cleanWord,
          index,
          words.length,
          intonationType,
          posMap
        );

        // Create SVG for intonation line - size it to match word width more closely
        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.setAttribute("class", "intonation-line");
        const svgWidth = Math.max(word.length * 6 + 10, 30); // Reduced multiplier and minimum
        svg.setAttribute("viewBox", `0 0 ${svgWidth} 45`);
        svg.style.width = `${svgWidth}px`;
        svg.style.maxWidth = `${word.length * 8}px`; // Cap the maximum width

        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        const pathData = generateDetailedIntonationPath(
          word,
          syllables,
          stressPattern,
          sentenceStress,
          index,
          words.length,
          intonationType
        );
        path.setAttribute("d", pathData);

        // Color coding based on stress levels
        // Combine syllable stress and sentence stress
        const maxSyllableStress = Math.max(...stressPattern);

        // Color coding based on combined stress levels
        let strokeColor = "#a0aec0"; // Default light gray for unstressed
        if (sentenceStress >= 3) strokeColor = "#e53e3e";
        // Red for primary stress
        else if (sentenceStress >= 2) strokeColor = "#f56500";
        // Orange for secondary stress
        else if (sentenceStress >= 1) strokeColor = "#667eea"; // Blue for slight stress

        path.setAttribute("stroke", strokeColor);
        let strokeWidth = "1.5"; // Unstressed (level 0)
        if (sentenceStress >= 3) strokeWidth = "3.5";
        // Primary (level 3)
        else if (sentenceStress >= 2) strokeWidth = "3";
        // Secondary (level 2)
        else if (sentenceStress >= 1) strokeWidth = "2"; // Weak (level 1)

        path.setAttribute("stroke-width", strokeWidth);
        path.setAttribute("fill", "none");

        svg.appendChild(path);
        wordContainer.appendChild(svg);
        createSentenceSwoosh(
          wordContainer,
          word,
          index,
          words.length,
          intonationType
        );

        // Create word text with stress indication
        const wordSpan = document.createElement("span");
        const hasStress = sentenceStress >= 2 || sentenceStress >= 2;
        wordSpan.className = "word-text" + (hasStress ? " stressed" : "");
        wordSpan.textContent = word;

        wordContainer.appendChild(wordSpan);

        // Add breath marks BEFORE conjunctions, relative pronouns, and long prepositional phrases
        if (shouldAddBreathMarkBefore(word, index, words)) {
          const breathMark = document.createElement("div");
          breathMark.className = "breath-mark";
          breathMark.style.position = "absolute";
          breathMark.style.left = "-15px"; // Position it to the left of the word
          wordContainer.appendChild(breathMark);
        }

        // Add breath marks after punctuation
        if (shouldAddBreathMark(word, index, words)) {
          const breathMark = document.createElement("div");
          breathMark.className = "breath-mark";
          wordContainer.appendChild(breathMark);
        }

        wordContainer.appendChild(wordSpan);
        sentenceDiv.appendChild(wordContainer);
      });

      visualization.appendChild(sentenceDiv);
    }
  });
}

function detectIntonationType(sentence) {
  const trimmed = sentence.trim();
  const lastChar = trimmed[trimmed.length - 1];

  if (lastChar === "?") {
    // Distinguish between yes/no questions and wh-questions
    const whWords = ["what", "where", "when", "why", "who", "how", "which", "whose"];
    const firstWord = trimmed.split(" ")[0].toLowerCase().replace(/[^\w]/g, "");
    return whWords.includes(firstWord) ? "wh-question" : "yes-no-question";
  } else if (lastChar === "!") {
    return "exclamation";
  } else if (lastChar === ".") {
    return "statement";
  } else if (trimmed.includes(",")) {
    return "list";
  }
  return "statement"; // Default fallback
}

function shouldAddBreathMark(word, index, words) {
  // Check if current word has punctuation (comma, semicolon, colon)
  if (word.match(/[,;:]/)) {
    return true;
  }

  return false;
}
function shouldAddBreathMarkBefore(word, index, words) {
  // Don't add breath mark before the first word
  if (index === 0) {
    return false;
  }

  // Check if the previous word has punctuation - if so, don't add another breath mark
  const previousWord = words[index - 1];
  if (previousWord && previousWord.match(/[,;:]/)) {
    return false;
  }

  // Common conjunctions that create natural pauses
  const conjunctions = new Set([
    "and", "but", "or", "so", "yet", "for", "nor", "because", "although",
    "though", "however", "nonetheless", "while", "since", "unless", "until",
    "if", "when", "where", "whereas"
  ]);
  
  const cleanWord = word.toLowerCase().replace(/[^\w]/g, "");
  
  // Relative pronouns that start clauses
  const relativePronouns = new Set([
    "who", "whom", "whose", "which", "that", "where", "when"
  ]);
  
  // Long prepositional phrases (preposition + 3+ words)
  const prepositions = new Set([
    "in", "on", "at", "by", "for", "with", "without", "through", "during",
    "before", "after", "above", "below", "under", "over", "between", "among",
    "beyond", "beneath", "beside"
  ]);

  // Check if current word is "even" and is followed by a conjunction, relative pronoun, or preposition
  if (cleanWord === "even" && index < words.length - 1) {
    const nextWord = words[index + 1].toLowerCase().replace(/[^\w]/g, "");
    if (conjunctions.has(nextWord) || relativePronouns.has(nextWord) || prepositions.has(nextWord)) {
      return true;
    }
  }

  // Check conjunctions (skip if preceded by "even")
  if (conjunctions.has(cleanWord)) {
    if (index > 0 && words[index - 1].toLowerCase().replace(/[^\w]/g, "") === "even") {
      return false;
    }
    return true;
  }

  // Check relative pronouns (skip if preceded by "even")
  if (relativePronouns.has(cleanWord)) {
    if (index > 0 && words[index - 1].toLowerCase().replace(/[^\w]/g, "") === "even") {
      return false;
    }
    return true;
  }

  // Check prepositions for long phrases (skip if preceded by "even")
  if (prepositions.has(cleanWord)) {
    // Check if this starts a phrase of 3+ words
    let phraseLength = 0;
    for (let i = index; i < Math.min(index + 4, words.length); i++) {
      phraseLength++;
    }

    if (phraseLength >= 3) {
      // Check if "even" appears directly before this preposition
      if (index > 0) {
        const prevWord = words[index - 1].toLowerCase().replace(/[^\w]/g, "");
        if (prevWord === "even") {
          return false;
        }
      }
      return true;
    }
  }

  return false;
}

function createSyllableArray(word, count) {
  if (count === 1) return [word];
  const syllables = [];
  const avgLength = word.length / count;
  for (let i = 0; i < count; i++) {
    const start = Math.round(i * avgLength);
    const end = i === count - 1 ? word.length : Math.round((i + 1) * avgLength);
    syllables.push(word.substring(start, end));
  }
  return syllables;
}

function getImprovedSyllables(word) {
  // First check CMU dictionary if available
  if (cmuDict && word) {
    const upperWord = word.toUpperCase();
    if (cmuDict[upperWord]) {
      const cmuStressPattern = getStressPatternFromCMU(cmuDict[upperWord]);
      if (cmuStressPattern.length > 0) {
        return createSyllableArray(word, cmuStressPattern.length);
      }
    }
  }

  // Fallback to your original syllable detection
  const syllableOverrides = {
    compared: 2,
    compare: 2,
    sharefull: 2,
    shareful: 2,
    Sharefull: 2,
    client: 2,
    scale: 1,
    fee: 1,
    area: 3,
    creates: 2,
    buyers: 2,
    create: 2,
    buyer: 2,
    rate: 1,
    rates: 1,
    GMV: 3,
    gmv: 3
  };

  // Check for exact matches first (including plurals)
  const baseWord = word.replace(/s$/, ""); // Remove trailing 's'
  if (syllableOverrides[word]) {
    return createSyllableArray(word, syllableOverrides[word]);
  }
  if (syllableOverrides[baseWord]) {
    return createSyllableArray(word, syllableOverrides[baseWord]);
  }

  if (!word || word.length === 0) return [""];

  // Handle acronyms - if word is all uppercase, treat each letter as a syllable
  const acronymExceptions = new Set(["LINE"]);
  if (word.match(/^[A-Z]{2,}$/) && !acronymExceptions.has(word)) {
    return word.split("");
  }

  word = word.toLowerCase();

  // Handle numerals - each digit gets its own syllable with primary stress
  if (word.match(/^\d+$/)) {
    if (word === "12" || word === "10") {
      return [word]; // Single syllable
    }
    return word.split("");
  }

  let syllableCount;

  // Handle "es" endings FIRST, before general vowel counting
  if (word.endsWith("es")) {
    const beforeEs = word.slice(0, -2);
    // Only count "es" as separate syllable after true sibilants that need the extra vowel sound
    if (beforeEs.match(/(ss|zz|x|sh|ch)$/)) {
      // For words like "glasses", "buzzes", "boxes", "wishes", "catches"
      // Count syllables in the base word, then add 1 for the "es"
      const baseCount = (beforeEs.match(/[aeiouy]+/g) || []).length;
      syllableCount = baseCount + 1;
    } else {
      // For words like "scores", "sales", "states", "games", "comes"
      // The "es" is really just "s" - don't count the "e"
      const baseWord = beforeEs + "s"; // Convert "scores" to "score" + "s"
      syllableCount = (beforeEs.match(/[aeiouy]+/g) || []).length;
    }
  } else {
    // Original vowel counting logic for non-"es" words
    syllableCount = (word.match(/[aeiouy]+/g) || []).length;
  }

  // Adjust for silent e
  if (
    word.endsWith("e") &&
    !word.endsWith("ue") &&
    !word.endsWith("ee") &&
    syllableCount > 1
  ) {
    syllableCount--;
  }

  // Handle final "ue" and "ee" - DO count as separate syllables
  if ((word.endsWith("ue") || word.endsWith("ee")) && syllableCount === 1) {
    syllableCount = 2; // Ensure "ue" and "ee" words have at least 2 syllables
  }

  // Adjust for common patterns
  if (word.match(/le$/)) syllableCount++; // -le ending adds syllable
  if (word.match(/ed$/) && !word.match(/[aeiou]ed$/) && !word.match(/[td]ed$/))
    syllableCount--; // silent -ed except after t/d

  syllableCount = Math.max(1, syllableCount);

  // Handle contractions for syllable counting
  if (word.includes("'")) {
    // Contractions that don't add syllables: 's, 'll, 'd, 're, 've
    if (word.match(/'(s|ll|d|re|ve)$/i)) {
      const baseWord = word.replace(/'(s|ll|d|re|ve)$/i, "");
      return getImprovedSyllables(baseWord);
    }
    // Contractions with 't that DO add syllables when preceded by 'n'
    else if (word.match(/n't$/i)) {
      const baseWord = word.replace(/n't$/i, "");
      return createSyllableArray(
        word,
        getImprovedSyllables(baseWord).length + 1
      );
    }
    // Other 't contractions that might not follow the 'n' rule
    else if (word.match(/'t$/i) && !word.match(/n't$/i)) {
      const baseWord = word.replace(/'t$/i, "");
      return getImprovedSyllables(baseWord);
    }
  }

  // Simple syllable division
  if (syllableCount === 1) return [word];

  const syllables = [];
  const avgLength = word.length / syllableCount;

  for (let i = 0; i < syllableCount; i++) {
    const start = Math.round(i * avgLength);
    const end =
      i === syllableCount - 1 ? word.length : Math.round((i + 1) * avgLength);
    syllables.push(word.substring(start, end));
  }

  return syllables;
}

function getSyllableStress(word, syllables, isAcronym = false) {
  // First check CMU dictionary if available
  if (cmuDict && word) {
    const upperWord = word.toUpperCase();
    if (cmuDict[upperWord]) {
      const cmuStressPattern = getStressPatternFromCMU(cmuDict[upperWord]);
      if (cmuStressPattern.length > 0) {
        return cmuStressPattern;
      }
    }
  }

  // Fallback to your original stress detection logic
  if (isAcronym) {
    return new Array(syllables.length).fill(3);
  }

  // Returns array of stress levels for each syllable (0-3)

  // Numerals get primary stress on each digit - check syllables too
  if (word.match(/^\d+$/) || syllables.every((syl) => syl.match(/^\d$/))) {
    return new Array(syllables.length).fill(3);
  }

  if (syllables.length === 1) {
    // Monosyllabic words
    if (functionWords.has(word)) return [0];
    return [2]; // Content words get some stress
  }

  const stressPattern = new Array(syllables.length).fill(0);

  // Apply stress rules in order of priority
  if (applyStressRules(word, stressPattern, syllables)) {
    return stressPattern;
  }

  // Default fallback - stress first syllable
  stressPattern[0] = 3;
  return stressPattern;
}

// [Continue with all your other original functions: applyStressRules, getSentenceStress, generateDetailedIntonationPath, createSentenceSwoosh, etc.]

function applyStressRules(word, stressPattern, syllables) {
  const len = syllables.length;

  // Helper function to remove common suffixes
  function getBaseWord(word) {
    const lowerWord = word.toLowerCase();

    // Remove common suffixes in order of length (longest first to avoid partial matches)
    const suffixes = ["es", "ed", "ly", "s", "d", "'s"];

    for (const suffix of suffixes) {
      if (lowerWord.endsWith(suffix)) {
        return lowerWord.slice(0, -suffix.length);
      }
    }

    return lowerWord;
  }

  // Rule 6: Suffixes that take primary stress
  if (
    word.match(/(ade|ee|ese|eer|teen|que|ette|oon)$/) &&
    word.toLowerCase() !== "timee"
  ) {
    stressPattern[len - 1] = 3; // Stress on suffix
    return true;
  }

  // Rule for -ism and -ship suffixes
  if (word.match(/(ism|ship)$/)) {
    // Check if word starts with unstressed prefixes (but exclude "despot" words)
    if (word.match(/^(de|dis|il|re|un|im)/) && !word.match(/^despot/)) {
      stressPattern[1] = 3; // Second syllable for prefixed words
    } else {
      stressPattern[0] = 3; // First syllable for non-prefixed words
    }
    return true;
  }

  // Rule 7: words where the stressed syllable is right before suffix
  if (
    word.match(
      /(ic|sion|tion|ment|ness|ive|ance|ancy|ence|ency|logy|ity)(s|al|ally)?$/
    )
  ) {
    let suffixSyllables = 1;
    if (word.match(/ically$/)) suffixSyllables = 3;
    // -ically is 3 syllables (i-cal-ly)
    else if (word.match(/(ic|sion|tion|ment|ness)ally$/)) suffixSyllables = 3;
    // -ally is 2 syllables, total 3
    else if (word.match(/(ic|sion|tion|ment|ness)al$/)) suffixSyllables = 2; // -al is 1 syllable, total 2

    const stressPos = len - suffixSyllables - 1; // Syllable right before suffix
    if (stressPos >= 0) {
      stressPattern[stressPos] = 3;
      return true;
    }
  }

  // Rule for -ing words with updated stress patterns
  if (word.match(/ing$/)) {
    const root = word.slice(0, -3);
    const rootSyllables = len - 1; // Total syllables minus the -ing syllable

    // Exceptions: words that stress first syllable regardless of length
    const firstSyllableExceptions = [
      "challenging",
      "listening",
      "gathering",
      "wandering",
      "wondering",
      "whispering",
      "traveling",
      "shimmering",
      "thundering",
      "trembling",
      "glittering",
      "chattering",
      "clattering",
      "shattering",
      "flattering",
      "scattering",
      "battering",
      "muttering",
      "buttering",
      "littering",
      "tittering",
      "guttering",
      "puttering",
      "shuttering",
      "cluttering",
      "happening",
      "harvesting",
      "promising",
      "suffering",
      "surfacing",
      "borrowing",
      "opening",
      "worrying",
      "following",
      "purchasing",
      "visiting",
      "picturing",
      "answering",
      "canceling",
      "entering",
      "balancing",
      "stabilizing",
      "offering",
      "marketing",
      "advertising",
      "targeting"
    ];

    if (firstSyllableExceptions.includes(word.toLowerCase())) {
      stressPattern[0] = 3; // First syllable stress for exceptions
      return true;
    }

    if (rootSyllables === 1) {
      // Single syllable roots like "launch", "list"
      stressPattern[0] = 3; // Stress the root syllable
      return true;
    } else if (len === 2) {
      // 2 syllable words: stress first syllable
      stressPattern[0] = 3; // First syllable stress
      return true;
    } else if (len >= 3) {
      // 3+ syllable words: stress second syllable
      stressPattern[1] = 3; // Second syllable stress
      return true;
    }
  }

  // Rule for words ending in -ed (past tense)
  if (word.match(/ed$/)) {
    // Exceptions: these -ed words stress the first syllable
    if (word === "upgraded" || word === "upskilled") {
      stressPattern[0] = 3; // First syllable
      return true;
    }
    if (len >= 3) {
      stressPattern[1] = 3; // Usually second syllable
      return true;
    }
  }

  // Rule 8: -cy, -ty, -phy, -gy, -al, -able, -ible stress third from end
  if (word.match(/(cy|ty|phy|gy|al|able|ible)s?$/)) {
    const stressPos = len - 3;
    if (stressPos >= 0) {
      stressPattern[stressPos] = 3;
      return true;
    }
  }

  // Rule for 4-syllable words - stress second syllable (except for above suffix rules)
  if (len === 4) {
    stressPattern[1] = 3; // Second syllable (index 1)
    return true;
  }

  // Rule 12: Reflexive pronouns - stress second syllable
  if (word.match(/^(my|your|him|her|it|our|them)sel(f|ves)$/)) {
    if (len >= 2) {
      stressPattern[1] = 3;
      return true;
    }
  }

  // Rule 13: Multiples of ten and "seven"- stress first syllable
  if (
    word.match(
      /^(seven|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|twenties|thirties|fourties|fifties|sixties|seventies|eighties|nineties)$/
    )
  ) {
    stressPattern[0] = 3;
    return true;
  }

  // Two-syllable function words (prepositions, conjunctions, etc.)
  if (len === 2 && functionWords.has(word)) {
    if (["after", "into", "over", "under"].includes(word)) {
      stressPattern[0] = 3; // These prepositions stress first syllable
    } else {
      stressPattern[1] = 3; // Most function words stress second syllable
    }
    return true;
  }

  // Two-syllable content words (nouns, verbs, adjectives)
  if (len === 2) {
    // Rule 2: Two-syllable nouns/adjectives - first syllable
    // Rule 3: Two-syllable verbs - second syllable

    // Check if it's likely a verb based on suffix patterns
    const verbSuffixes = /(act|age|ail|ain|and|are|ate|ify|ifies|ize|ise|ease|ete|ect|ose|ire|ive|ign|ply|plies|tain|vide|duce|ceive|port|strict|struct|gress|press|tract|spect|flect|cede|pose|move|prove|serve|solve|volve|pend|tend|mend|fend|scend|ude|ue|ult)[sd]?$/;
    if (word.match(verbSuffixes)) {
      stressPattern[1] = 3; // Verb pattern - second syllable
    } else {
      stressPattern[0] = 3; // Default to noun/adjective pattern - first syllable
    }
    return true;
  }

  // Compound word rules (Rules 9-11)
  if (word.includes("-") || isCompoundWord(word)) {
    return handleCompoundStress(word, stressPattern, syllables);
  }
  // Rule for words with first syllable stress (case-insensitive)
  const firstStressWords = [
    "positive",
    "ever",
    "after",
    "into",
    "over",
    "under",
    "further",
    "farther",
    "business",
    "timee",
    "frequency",
    "upgrade",
    "upskill",
    "sharefull",
    "category",
    "generates"
  ];
  if (firstStressWords.includes(getBaseWord(word))) {
    stressPattern[0] = 3; // first syllable
    return true;
  }

  // Rule for words with second syllable stress (case-insensitive)
  const secondStressWords = [
    "important",
    "however",
    "although",
    "objective",
    "unchanged",
    "significant",
    "mercari",
    "percentage",
    "percent",
    "expense",
    "effectively",
    "complaints",
    "continue"
  ];
  const baseWord = getBaseWord(word);
  if (secondStressWords.includes(baseWord)) {
    stressPattern[1] = 3; // Second syllable
    return true;
  }

  const thirdStressWords = [
    "altogether",
    "nationwide",
    "overall",
    "opportunities",
    "opportunity"
  ];
  const baseWord3 = getBaseWord(word);
  if (thirdStressWords.includes(getBaseWord(word))) {
    stressPattern[2] = 3; // third syllable
    return true;
  }

  // Three-syllable words
  if (len === 3) {
    // Rule 4: Three-syllable words ending in -er or -ly
    if (word.match(/(er|ers|ly|lies)$/)) {
      stressPattern[0] = 3;
      return true;
    }

    // Rule 5: Three-syllable words ending in consonant or y
    if (word.match(/[bcdfghjklmnpqrstvwxzy]$/)) {
      stressPattern[0] = 3;
      return true;
    }
  }
  return false;
}

function isCompoundWord(word) {
  // Simple compound detection - you can expand this list
  const compounds = [
    "homework",
    "basketball",
    "newspaper",
    "bedroom",
    "sunshine",
    "rainbow",
    "headquarter"
  ];
  return compounds.includes(word) || word.includes("-");
}

function handleCompoundStress(word, stressPattern, syllables) {
  // For now, default to first part stress (Rule 9 - compound nouns)
  // This is simplified - ideally you'd determine part of speech
  stressPattern[0] = 3;
  return true;
}

function getSentenceStress(word, position, totalWords, intonationType, posMap) {
  // Returns sentence-level stress (0-3)
  const cleanWord = word.replace(/[^\w']/g, "");

  // Check emphasis words first (highest priority)
  if (emphasisWords.has(cleanWord.toLowerCase())) return 3;

  // Use POS map from sentence analysis
  let posStress = getPOSBasedStressFromMap(cleanWord, posMap);

  // Adjust based on sentence position and intonation type
  let sentenceStress = posStress;

  switch (intonationType) {
    case "statement":
      if (position >= totalWords - 2 && posStress >= 2) {
        sentenceStress = 3;
      } else if (position === 0 && posStress >= 2) {
        sentenceStress = Math.min(3, posStress + 1);
      }
      break;

    case "wh-question":
      if (position === 0) sentenceStress = 3;
      else if (position >= totalWords - 2 && posStress >= 2) sentenceStress = 2;
      break;

    case "yes-no-question":
      if (position >= totalWords - 1 && posStress >= 2) sentenceStress = 3;
      else if (position <= 1 && posStress >= 2) sentenceStress = 2;
      break;

    case "exclamation":
      if (posStress >= 2) sentenceStress = Math.min(3, posStress + 1);
      if (position >= totalWords - 2) sentenceStress = 3;
      break;

    case "list":
      if (posStress >= 2) sentenceStress = 2;
      if (position >= totalWords - 1 && posStress >= 2) sentenceStress = 3;
      break;
  }

  return sentenceStress;
}
function getPOSBasedStressFromMap(word, posMap) {
  if (!word || word.length === 0) return 0;

  const lowerWord = word.toLowerCase();
  
  // Special cases: negative/quantifier words always get primary stress
  const emphasizedWords = new Set(["not", "never", "no", "none", "many", "much", "all", "nobody", "nothing", "every", "everything", "everyone", "everybody", "each", "always"]);
  if (emphasizedWords.has(lowerWord)) return 3;
  
  // Wh-words at sentence start (capitalized) get primary stress
  const whWords = new Set(["who", "what", "where", "when", "why", "how", "which", "whose"]);
  if (whWords.has(lowerWord) && word[0] === word[0].toUpperCase()) {
    return 3;
  }
  
  // Check function words first (before capitalization check)
  if (functionWords.has(lowerWord)) return 0;
  
  // Modal verbs get secondary stress (level 2)
  const modals = new Set([
    "can", "cannot", "can't", "could", "couldn't", "could've",
    "may", "might", "mightn't", "might've",
    "will", "won't", "would", "wouldn't", "would've",
    "shall", "shan't", "should", "shouldn't", "should've",
    "must", "mustn't", "must've"
  ]);
  if (modals.has(lowerWord)) return 2;
  
  // Other auxiliaries get no stress (level 0)
  const auxiliaries = new Set([
    "is", "isn't", "am", "are", "aren't", "was", "wasn't", "were", "weren't",
    "be", "been", "being",
    "have", "haven't", "has", "hasn't", "had", "hadn't",
    "do", "don't", "does", "doesn't", "did", "didn't"
  ]);
  if (auxiliaries.has(lowerWord)) return 0;

  // Capitalized words that aren't function words (likely proper nouns) get primary stress
  if (word[0] === word[0].toUpperCase() && word[0] !== word[0].toLowerCase()) {
    return 3;
  }

  // Get POS from map
  const pos = posMap.get(lowerWord);
  
  if (pos === "number") return 3;
  if (pos === "noun" || pos === "verb") return 3;
  if (pos === "adjective" || pos === "adverb") return 2;
  if (pos === "pronoun") return 1;
  if (pos === "preposition" || pos === "conjunction") return 0;

  // Suffix-based fallback for sentence stress
  
  // Noun suffixes -> primary stress (3)
  if (lowerWord.match(/(tion|sion|ness|ment|ance|ence|ancy|ency|ity|ty|ism|ist|er|or|age|ure|ship|hood|dom|tude|ery|ary|ory|ant|ent|logy|gy|metry|graphy|phy|ics|cy|ade|ette|let|ee|eer)$/)) {
    return 3;
  }
  
  // Verb suffixes and roots -> primary stress (3)
  if (lowerWord.match(/(ate|ify|ifies|ize|ise|yze|yse|en|ail|are|ease|ply|plies|tain|vide|duce|ceive|port|strict|struct|gress|press|tract|spect|flect|cede|pose|move|prove|serve|solve|volve|pend|tend|mend|fend|scend|ult|ect|ire)$/)) {
    return 3;
  }
  
  // Adjective/Adverb suffixes -> secondary stress (2)
  if (lowerWord.match(/(ive|ous|ful|less|able|ible|al|ic|ly|ish|like|some|ward|wards|wise|proof|worthy|wide)$/)) {
    return 2;
  }

  // Default: if not in function words and not identified, give weak stress
  return 1;
}

function generateDetailedIntonationPath(
  word,
  syllables,
  syllableStress,
  sentenceStress,
  position,
  totalWords,
  intonationType
) {
  const width = Math.max(word.length * 6 + 10, 30);
  const height = 30;
  const baseY = height * 0.7;

  // Calculate base intonation for sentence type
  let sentenceContour = getSentenceContour(
    position,
    totalWords,
    intonationType
  );

  // Create path points for each syllable
  const points = [];
  const syllableWidth = (width - 20) / Math.max(syllables.length, 1);

  syllables.forEach((syllable, i) => {
    const x = 10 + i * syllableWidth + syllableWidth / 2;
    const stress = syllableStress[i];

    // Base height calculation with more distinct levels
    let y = baseY;

    // Adjust for syllable stress (higher = more stressed)
    switch (stress) {
      case 3: // Primary stress
        y = height * 0.1;
        break;
      case 2: // Secondary stress
        y = height * 0.3;
        break;
      case 1: // Weak stress
        y = height * 0.5;
        break;
      case 0: // Unstressed
        y = height * 0.75;
        break;
    }

    // Adjust for sentence-level stress
    const sentenceAdjustment = (sentenceStress - 1) * (height * 0.08);
    y = Math.max(height * 0.05, y - sentenceAdjustment);

    // Apply sentence contour
    y += sentenceContour * (height * 0.15);

    // Ensure y stays within bounds
    y = Math.max(height * 0.05, Math.min(height * 0.9, y));

    points.push({ x, y, stress, syllable });
  });

  if (points.length === 1) {
    // Single syllable - simple curve
    const p = points[0];
    const startX = 8;
    const endX = width - 8;
    return `M ${startX} ${p.y} L ${p.x - 5} ${p.y} L ${p.x + 5} ${
      p.y
    } L ${endX} ${p.y}`;
  }

  // Multi-syllable - create path with syllable breaks and diagonal connections
  let path = `M 2 ${points[0].y}`;

  for (let i = 0; i < points.length; i++) {
    const curr = points[i];

    if (i > 0) {
      const prev = points[i - 1];

      // Calculate syllable boundary position
      const boundaryX = prev.x + (curr.x - prev.x) / 2;

      // Check if we need diagonal connection (different stress levels)
      if (prev.y !== curr.y) {
        // Different stress levels - use diagonal connection
        path += ` L ${boundaryX - 3} ${prev.y}`;
        path += ` L ${boundaryX + 3} ${curr.y}`;
      } else {
        // Same stress level - use gap as before
        path += ` L ${boundaryX - 3} ${prev.y}`;
        path += ` M ${boundaryX + 3} ${curr.y}`;
      }
    }

    // Draw to current syllable position
    path += ` L ${curr.x} ${curr.y}`;

    // Add small plateau at syllable peak for clarity
    if (i < points.length - 1) {
      const next = points[i + 1];
      const plateauEnd = Math.min(curr.x + 8, (curr.x + next.x) / 2 - 5);
      path += ` L ${plateauEnd} ${curr.y}`;
    }
  }

  // End at the edge
  const lastPoint = points[points.length - 1];
  path += ` L ${width - 2} ${lastPoint.y}`;

  return path;
}

function getSentenceContour(position, totalWords, intonationType) {
  return 0; // No adjustment to word stress lines
}

function createSentenceSwoosh(
  wordContainer,
  word,
  position,
  totalWords,
  intonationType
) {
  // Only add swoosh to the last word in the sentence
  if (position < totalWords - 1) {
    return;
  }

  // Create separate SVG for sentence swoosh
  const swooshSvg = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "svg"
  );
  swooshSvg.style.position = "absolute";
  swooshSvg.style.top = "-70px";
  swooshSvg.style.left = "0";
  swooshSvg.style.right = "-30px";
  swooshSvg.style.height = "25px";
  swooshSvg.style.pointerEvents = "none";

  const svgWidth = Math.max(word.length * 6 + 40, 60);
  swooshSvg.setAttribute("viewBox", `0 0 ${svgWidth} 25`);
  swooshSvg.style.width = `${svgWidth}px`;

  const swooshPath = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "path"
  );

  // Generate clean swoosh without arrowhead
  let pathData;
  const endX = svgWidth - 5;
  const midX = (5 + endX) / 2;
  const startX = midX; // Start from the middle instead of the beginning

  switch (intonationType) {
    case "yes-no-question":
    case "exclamation":
      // Half upward swoosh - start at middle, curve up to end
      pathData = `M ${midX} 18 Q ${midX + (endX - midX) * 0.7} 12 ${endX} 6`;
      break;
    default:
      // wh-question, statement, etc.
      // Half downward swoosh - start at middle, curve down to end
      pathData = `M ${midX} 8 Q ${midX + (endX - midX) * 0.7} 14 ${endX} 20`;
      break;
  }

  swooshPath.setAttribute("d", pathData);
  swooshPath.setAttribute("stroke", "#9f7aea");
  swooshPath.setAttribute("stroke-width", "2.5");
  swooshPath.setAttribute("fill", "none");
  swooshPath.setAttribute("opacity", "0.8");
  swooshPath.setAttribute("stroke-linecap", "round");

  swooshSvg.appendChild(swooshPath);
  wordContainer.appendChild(swooshSvg);
}
function generateIntonationPath(
  word,
  position,
  totalWords,
  intonationType,
  isStressed
) {
  const width = word.length * 8 + 20;
  const height = 30;
  const midY = height / 2;

  let startY, endY, controlY;

  // Base pitch patterns by intonation type
  switch (intonationType) {
    case "yes-no-question":
      // Rising intonation
      startY = midY + 5;
      endY = midY - 10;
      controlY = midY - 5;
      break;

    case "wh-question":
      // High start, falling
      startY = midY - 8;
      endY = midY + 8;
      controlY = midY;
      break;

    case "exclamation":
      // High plateau with emphasis
      startY = midY - 10;
      endY = midY - 8;
      controlY = midY - 12;
      break;

    case "list":
      // Rising on non-final items, falling on final
      if (position < totalWords - 1) {
        startY = midY + 2;
        endY = midY - 5;
        controlY = midY - 2;
      } else {
        startY = midY - 2;
        endY = midY + 8;
        controlY = midY + 3;
      }
      break;

    default:
      // statement
      // Generally falling, with emphasis on stressed words
      const progressRatio = position / (totalWords - 1);
      startY = midY - 5 + progressRatio * 10;
      endY = midY + 5 + progressRatio * 5;
      controlY = midY + progressRatio * 2;
  }

  // Modify for stress
  if (isStressed) {
    startY -= 5;
    controlY -= 8;
    if (intonationType === "exclamation") {
      controlY -= 5; // Extra emphasis for exclamations
    }
  }

  // Ensure values stay within bounds
  startY = Math.max(2, Math.min(height - 2, startY));
  endY = Math.max(2, Math.min(height - 2, endY));
  controlY = Math.max(2, Math.min(height - 2, controlY));

  // Create smooth curve
  const startX = 5;
  const endX = width - 5;
  const controlX = width / 2;

  return `M ${startX} ${startY} Q ${controlX} ${controlY} ${endX} ${endY}`;
}

// Initialize with default text
document.addEventListener("DOMContentLoaded", function () {
  analyzeIntonation();
});

// Allow Enter key to analyze
document.getElementById("textInput").addEventListener("keypress", function (e) {
  if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
    analyzeIntonation();
  }
});

   </script>
</body>
</html>
